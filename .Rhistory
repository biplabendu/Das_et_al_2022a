"./data/databases/TC6_fungal_data.db")
src_dbi(data.db)
sample.name = "beau"
# A1: genes that have NO expression (FPKM == 0 at all time points)
not.expressed <-
tbl(data.db, paste0(sample.name ,"_fpkm")) %>%
collect() %>%
filter_at(vars(starts_with("Z")), all_vars(. == 0)) %>%
pull(gene_name)
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
not.expressed %>%
go_enrichment(.,
org = "beau",
bg = 'all') %>%  # enrichment against all ophio_cflo genes in the genome
go_enrichment_plot(clean = "no")
species_name <- 'beau'
DB_name_Robin <- 'Beaba1'
DB_name_NCBI <- 'ARSEF2860'
path_R <- paste0('./Das_et_al_2022a/data/input/',{species_name},'/', {DB_name_Robin},'.genes.gff3')
path_NCBI <- paste0('./Das_et_al_2022a/data/input/',{species_name},'/',{species_name},'_',{DB_name_NCBI},'_genome.gff')
gff_robin <- read.csv(path_R, sep = '\t', header = F, stringsAsFactors = F)
gff_ncbi <- read.csv(path_NCBI, sep = '\t', header = F, stringsAsFactors = F)
getwd()
setwd("~/Dropbox/Ant-fungus/02_git/Git_Das_folder2")
gff_robin <- read.csv(path_R, sep = '\t', header = F, stringsAsFactors = F)
gff_ncbi <- read.csv(path_NCBI, sep = '\t', header = F, stringsAsFactors = F)
col_names <- c('seqname','source','feature','start','end','score','strand','frame','attributes')
colnames(gff_robin) <- col_names
colnames(gff_ncbi) <- col_names
# load libraries
library(tidyverse)
gff_robin <- gff_robin %>%
filter(feature == "gene") %>%
select(start, end, attributes_robin = attributes)
gff_ncbi <- gff_ncbi %>%
filter(feature == "gene") %>%
select(start, end, attributes_ncbi = attributes)
head(gff_robin)
head(gff_ncbi)
## Robin's annotation
# initial split
foo <- gff_robin %>%
separate(attributes_robin, c("a","b"), "=", extra = "merge")
# final split to obtain only the gene names
gff_robin$attributes_robin <- unlist(strsplit(foo$b,"|gene",4))
## NCBI's annotation
# all-in-one
gff_ncbi <-
gff_ncbi %>%
separate(attributes_ncbi, c("a","b","c"), ";", extra = "merge") %>%
select(-c(a,c)) %>%
separate(b, c("b","c"), "=", extra = "merge") %>%
select(start, end, attributes_ncbi=c)
gff_robin_ncbi <-
gff_robin %>%
full_join(gff_ncbi)
# SAVE THE FILE
file_name <- paste0('./Das_et_al_2022a/data/input/',{species_name},'/',{species_name},'_gene_names_robin_ncbi.csv')
write.csv(gff_robin_ncbi,
file = file_name,
row.names = F)
# Housekeeping ---------------------------------------------------------------
#
set.seed(420)
rm(list = ls())
#
## Load packages ----------
pacman::p_load(pheatmap, dendextend, tidyverse, viridis, ggthemes)
pacman::p_load(RSQLite, tidyverse, dbplyr, DT, conflicted)
#
# set conflict preference (housekeeping to make sure functions work as expected)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("layout", "plotly")
#
## load functions ---------
source("./functions/enrichment_analysis.R")
#
## set parameters and thresholds --------
#
# gamma-pvalue threshold for inferring rhythmicity
gamma.pval = 0.05
# 00. Load Databases -----------------------------------------------------------
#
# 1. TC7_ejtk.db
# Desc: This database contains all ejtk-output for TC7
ejtk.db <- dbConnect(RSQLite::SQLite(),
"./data/databases/TC6_fungal_ejtk.db")
# which tables are in the database
src_dbi(ejtk.db)
#
# 2. TC7_data.db
data.db <- dbConnect(RSQLite::SQLite(),
"./data/databases/TC6_fungal_data.db")
src_dbi(data.db)
sample.name = "beau"
# A1: genes that have NO expression (FPKM == 0 at all time points)
not.expressed <-
tbl(data.db, paste0(sample.name ,"_fpkm")) %>%
collect() %>%
filter_at(vars(starts_with("Z")), all_vars(. == 0)) %>%
pull(gene_name)
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
not.expressed %>%
go_enrichment(.,
org = "beau",
bg = 'all') %>%  # enrichment against all ophio_cflo genes in the genome
go_enrichment_plot(clean = "no")
setwd("~/Dropbox/Ant-fungus/02_git/Git_Das_folder2/Das_et_al_2022a")
# Housekeeping ---------------------------------------------------------------
#
set.seed(420)
rm(list = ls())
#
## Load packages ----------
pacman::p_load(pheatmap, dendextend, tidyverse, viridis, ggthemes)
pacman::p_load(RSQLite, tidyverse, dbplyr, DT, conflicted)
#
# set conflict preference (housekeeping to make sure functions work as expected)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("layout", "plotly")
#
## load functions ---------
source("./functions/enrichment_analysis.R")
#
## set parameters and thresholds --------
#
# gamma-pvalue threshold for inferring rhythmicity
gamma.pval = 0.05
# 00. Load Databases -----------------------------------------------------------
#
# 1. TC7_ejtk.db
# Desc: This database contains all ejtk-output for TC7
ejtk.db <- dbConnect(RSQLite::SQLite(),
"./data/databases/TC6_fungal_ejtk.db")
# which tables are in the database
src_dbi(ejtk.db)
#
# 2. TC7_data.db
data.db <- dbConnect(RSQLite::SQLite(),
"./data/databases/TC6_fungal_data.db")
src_dbi(data.db)
sample.name = "beau"
# A1: genes that have NO expression (FPKM == 0 at all time points)
not.expressed <-
tbl(data.db, paste0(sample.name ,"_fpkm")) %>%
collect() %>%
filter_at(vars(starts_with("Z")), all_vars(. == 0)) %>%
pull(gene_name)
write(not.expressed, file = past0('./results/',{sample.name},'_not_expressed_list.txt'),
sep = " ")
write(not.expressed, file = paste0('./results/',{sample.name},'_not_expressed_list.txt'),
sep = " ")
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
not.expressed %>%
go_enrichment(.,
org = "beau",
bg = 'all') %>%  # enrichment against all ophio_cflo genes in the genome
go_enrichment_plot(clean = "no")
# B: genes that are expressed (FPKM > 1 for at least one time point)
expressed <-
tbl(data.db, paste0(sample.name,"_expressed_genes")) %>%
filter(expressed=="yes") %>%
collect() %>%
pull(gene_name)
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
not.expressed %>%
go_enrichment(.,
org = "beau",
bg = 'all') %>%  # enrichment against all ophio_cflo genes in the genome
go_enrichment_plot(clean = "no")
## Load all the rhythmic genesets
## Note, ordered according to their p-value; highly rhythmic at the top.
#
# Choose period
period = '24'
# Ultradian genes (period = 8h)
##
rhy <-
tbl(ejtk.db, paste0(sample.name,"_zscores_",period,'h')) %>%
filter(GammaP < gamma.pval) %>%
select(ID, GammaP) %>% collect() %>% arrange(GammaP) %>%
select(ID) %>% pull()
## load zscore dataset
zscore.dat <- data.db %>% tbl(., paste0(sample.name,"_zscores")) %>% collect()
# Filter the zscores to keep only rhythmic genes
zscore.rhy <-
zscore.dat %>%
filter(gene_name %in% rhy) %>%
as.data.frame()
# Set genes as rownames and convert it into a matrix
rownames(zscore.rhy) = zscore.rhy$gene_name
zscore.rhy <- as.matrix(zscore.rhy[-1])
# Hierarchical clustering of the genesets
my_hclust_gene <- hclust(dist(zscore.rhy), method = "complete")
# Make annotations for the heatmaps
my_gene_col <- cutree(tree = as.dendrogram(my_hclust_gene), k = 2) # k=  clusters
my_gene_col <- data.frame(cluster = my_gene_col)
# I’ll add some column annotations and create the heatmap.
# Annotations for:
# 1. Is the sample collected during the light or dark phase?
my_sample_col <- data.frame(phase = rep(c("light", "dark", "light"), c(5,6,1)))
row.names(my_sample_col) <- colnames(zscore.rhy)
# Manual color palette
my_colour = list(
phase = c(light = "#F2E205", dark = "#010440"),
cluster = viridis::cividis(100)[c(40,60)])
# Color scale
my.breaks = seq(min(zscore.rhy), max(zscore.rhy), by=0.1)
# Let's plot!
rhy.heat <-
pheatmap(zscore.rhy, show_rownames = F, show_colnames = F,
annotation_row = my_gene_col,
annotation_col = my_sample_col,
cutree_rows = 2, # OG was 4
cutree_cols = 2,
annotation_colors = my_colour,
border_color=FALSE,
cluster_cols = F,
breaks = my.breaks,
## color scheme borrowed from:
color = inferno(length(my.breaks) - 1),
# treeheight_row = 0,
# treeheight_col = 0,
# remove the color scale or not
# main = paste0("Foragers - circadian genes \n (n=", nrow(cflo.rhy.exp.for), " genes)"),
## annotation legend
annotation_legend = T,
## Color scale
legend = T)
## day-peaking | cluster 3 ##
rhy.24.daypeaking.cluster3 <-
my_gene_col %>%
rownames_to_column(var = "gene") %>%
filter(cluster == 3) %>%
pull(gene) %>%
# run enrichment analysis
go_enrichment(.,
org = "ophio_cflo",
bg = expressed) # enrichment against all expressed ophio_cflo genes
rhy.24.daypeaking.cluster3 <-
my_gene_col %>%
rownames_to_column(var = "gene") %>%
filter(cluster == 3) %>%
pull(gene) %>%
# run enrichment analysis
go_enrichment(.,
org = "beau",
bg = expressed) # enrichment against all expressed ophio_cflo genes
# view the results
rhy.24.daypeaking.cluster3 %>% view()
## night-peaking | cluster 1 ##
rhy.24.nightpeaking.cluster1 <-
my_gene_col %>%
rownames_to_column(var = "gene") %>%
filter(cluster == 1) %>%
pull(gene) %>%
go_enrichment(.,
org = "beau",
bg = "expressed")
# Housekeeping ---------------------------------------------------------------
#
set.seed(420)
rm(list = ls())
#
## Load packages ----------
pacman::p_load(pheatmap, dendextend, tidyverse, viridis, ggthemes)
pacman::p_load(RSQLite, tidyverse, dbplyr, DT, conflicted)
#
# set conflict preference (housekeeping to make sure functions work as expected)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("layout", "plotly")
#
## load functions ---------
source("./functions/enrichment_analysis.R")
#
## set parameters and thresholds --------
#
# gamma-pvalue threshold for inferring rhythmicity
gamma.pval = 0.05
# 00. Load Databases -----------------------------------------------------------
#
# 1. TC7_ejtk.db
# Desc: This database contains all ejtk-output for TC7
ejtk.db <- dbConnect(RSQLite::SQLite(),
"./data/databases/TC6_fungal_ejtk.db")
# which tables are in the database
src_dbi(ejtk.db)
#
# 2. TC7_data.db
data.db <- dbConnect(RSQLite::SQLite(),
"./data/databases/TC6_fungal_data.db")
src_dbi(data.db)
sample.name = "beau"
# A1: genes that have NO expression (FPKM == 0 at all time points)
not.expressed <-
tbl(data.db, paste0(sample.name ,"_fpkm")) %>%
collect() %>%
filter_at(vars(starts_with("Z")), all_vars(. == 0)) %>%
pull(gene_name)
write(not.expressed, file = paste0('./results/',{sample.name},'_not_expressed_list.txt'),
sep = " ")
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
not.expressed %>%
go_enrichment(.,
org = "beau",
bg = 'all') %>%  # enrichment against all ophio_cflo genes in the genome
go_enrichment_plot(clean = "no")
# B: genes that are expressed (FPKM > 1 for at least one time point)
expressed <-
tbl(data.db, paste0(sample.name,"_expressed_genes")) %>%
filter(expressed=="yes") %>%
collect() %>%
pull(gene_name)
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
not.expressed %>%
go_enrichment(.,
org = "beau",
bg = 'all') %>%  # enrichment against all ophio_cflo genes in the genome
go_enrichment_plot(clean = "no")
install.packages("igraph")
pwd()
getwd()
setwd("~/Dropbox/Ant-fungus/02_git/Git_Das_folder2")
install.packages("xfun")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)
## For more inspiration on customizing the html output, refer to the following:
# https://bookdown.org/yihui/rmarkdown/html-document.html#table-of-contents
set.seed(420)
rm(list = ls())
#' Load the libraries
pacman::p_load(pheatmap, dendextend, tidyverse, viridis)
pacman::p_load(RSQLite, tidyverse, dbplyr, DT, conflicted, WGCNA, igraph)
#' set conflict preference
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("layout", "plotly")
conflict_prefer("hclust", "flashClust")
#' set path to your working directory
path_to_repo = "./Das_et_al_2022b"
#' load functions
# customized theme for publication quality figures
source(paste0(path_to_repo,"/functions/theme_publication.R"))
# function to perform enrichment analysis
source(paste0(path_to_repo,"/functions/enrichment_analysis.R"))
# function to plot z-scores (Cflo genes only)
source(paste0(path_to_repo,"/functions/plot_zscores.R"))
# loading database which contains data for Das and de Bekker 2021 (bioRxiv)
db <- dbConnect(RSQLite::SQLite(), paste0(path_to_repo,"/data/databases/TC7_data.db"))
# specify sample name
sample.name <- "cflo_control"
# extract the (gene-expr X time-point) data
dat <-
db %>%
tbl(., paste0(sample.name ,"_fpkm")) %>%
select(gene_name, everything()) %>%
collect()
writeLines("What is the dimensions of the original dataset? [Rows = #genes, Cols = #samples]")
dim(dat[-1])
# loading database which contains data for Das and de Bekker 2021 (bioRxiv)
db <- dbConnect(RSQLite::SQLite(), paste0(path_to_repo,"/data/databases/TC7_data.db"))
# specify sample name
sample.name <- "beau"
# extract the (gene-expr X time-point) data
dat <-
db %>%
tbl(., paste0(sample.name ,"_fpkm")) %>%
select(gene_name, everything()) %>%
collect()
writeLines("What is the dimensions of the original dataset? [Rows = #genes, Cols = #samples]")
dim(dat[-1])
# Which genes are expressed throughout the day in forager heads?
# count the number of time points that has ≥ 1 FPKM
n.expressed <- apply(dat[-1], 1, function(x) sum(x >= 1))
# subset the data and only keep the filtered genes
dat <- dat[which(n.expressed >=6),]
writeLines("Dimensions of the data post-filtering step [Rows = #genes, Cols = #samples]")
dim(dat)
datExpr = as.data.frame(t(log2(dat[-c(1)]+1)))
names(datExpr) = dat$gene_name
rownames(datExpr) = names(dat)[-c(1)]
# USE THE FOLLOWING CODE TO CHECK IF YOU HAVE ANY BAD SAMPLES #
# gsg = goodSamplesGenes(datExpr, verbose = 3);
# gsg$allOK
# sampleTree = hclust(dist(datExpr0), method = "average");
# # Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# # The user should change the dimensions if the window is too large or too small.
# sizeGrWindow(12,9)
# #pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
# par(cex = 1);
# par(mar = c(0,4,2,0))
# plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
#      cex.axis = 1.5, cex.main = 2)
# save the number of genes and samples
# that will be used to create the circadian GCN
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)
# visualize the log-transformed data
x = reshape2::melt(as.matrix(t(datExpr)))
colnames(x) = c('gene_id', 'sample', 'value')
writeLines("Visualizing the log-transformed data")
ggplot(x, aes(x=value, color=sample)) + geom_density() + theme_Publication()
# Calculate Kendall's tau-b correlation for each gene-gene pair
# sim_matrix <- cor((datExpr), method = "kendall") # this step takes time
# save(sim_matrix, file = paste0(path_to_repo, "/results/temp_files/sim_matrix_", sample.name, "_TC7.RData")) # might be useful to save the sim_matrix and
load(paste0(path_to_repo, "/results/temp_files/sim_matrix_", sample.name, "_TC7.RData")) # load it up
## Let's display a chunk of the matrix (code from Hughitt 2016; github)
heatmap_indices <- sample(nrow(sim_matrix), 200)
writeLines(paste0("Plotting a chunk of the gene-gene similarity matrix with ", length(heatmap_indices), " genes."))
gplots::heatmap.2(t(sim_matrix[heatmap_indices, heatmap_indices]),
col=inferno(100),
labRow=NA, labCol=NA,
trace='none', dendrogram='row',
xlab='Gene', ylab='Gene',
main= paste0("Similarity matrix \n correlation method = 'kendall' \n (", length(heatmap_indices), "random genes)"),
density.info='none', revC=TRUE)
# Calculate Kendall's tau-b correlation for each gene-gene pair
sim_matrix <- cor((datExpr), method = "kendall") # this step takes time
save(sim_matrix, file = paste0(path_to_repo, "/results/temp_files/sim_matrix_", sample.name, "_TC7.RData")) # might be useful to save the sim_matrix and
load(paste0(path_to_repo, "/results/temp_files/sim_matrix_", sample.name, "_TC7.RData")) # load it up
## Let's display a chunk of the matrix (code from Hughitt 2016; github)
heatmap_indices <- sample(nrow(sim_matrix), 200)
writeLines(paste0("Plotting a chunk of the gene-gene similarity matrix with ", length(heatmap_indices), " genes."))
gplots::heatmap.2(t(sim_matrix[heatmap_indices, heatmap_indices]),
col=inferno(100),
labRow=NA, labCol=NA,
trace='none', dendrogram='row',
xlab='Gene', ylab='Gene',
main= paste0("Similarity matrix \n correlation method = 'kendall' \n (", length(heatmap_indices), "random genes)"),
density.info='none', revC=TRUE)
writeLines("Performing network topology analysis to pick soft-thresholding power")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# # Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
writeLines("Plotting the resutls from the network topology analysis")
# Plot the results:
# sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
writeLines("Performing network topology analysis to pick soft-thresholding power")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# # Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
writeLines("Plotting the resutls from the network topology analysis")
# Plot the results:
# sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# # Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
install.packages("WGCNA")
writeLines("Performing network topology analysis to pick soft-thresholding power")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# # Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
writeLines("Plotting the resutls from the network topology analysis")
# Plot the results:
# sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
# # Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
library(WGCNA)
install.packages("UpSetR")
