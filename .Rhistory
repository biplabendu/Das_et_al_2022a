# Chunk 14: ortho_rhy_clusters
### Make the dataframe for plotting
zscore.rhy.homology.dat <-
zscore.dat[[1]] %>%
filter(gene_name %in% rhy.homology.dat[[1]]) %>%
rename_at(vars(starts_with("ZT")), ~ (gsub("A", "B", .x, fixed = TRUE))) %>% # fix colnames for beau
# add ophio homologs for the beau genes
left_join(rhy.homology.dat, by=c("gene_name" = "beau_gene")) %>%
# remove the beau names and keep the ophio names only
select(-1) %>%
select(gene_name = ophio_gene, everything()) %>%
# join ophio-cflo data
left_join(zscore.dat[[2]], by="gene_name") %>%
# drop any genes without expression values (NA)
na.omit() %>%
as.data.frame() %>%
# set genes as rownames
column_to_rownames("gene_name")
# Set genes as rownames and convert it into a matrix
# rownames(zscore.rhy.homology.dat) = zscore.rhy.homology.dat$gene_name
zscore.rhy.homology.dat <- as.matrix(zscore.rhy.homology.dat)
# Hierarchical clustering of the genesets
my_hclust_gene <- hclust(dist(zscore.rhy.homology.dat), method = "complete")
# Make annotations for the heatmaps
n_clusters <- 4
my_clusters <- cutree(tree = as.dendrogram(my_hclust_gene), k = n_clusters) # k=  clusters
my_gene_col <- data.frame(cluster = my_clusters)
# I’ll add some column annotations and create the heatmap.
# Annotations for:
# 1. Is the sample collected during the light or dark phase?
my_sample_col <- data.frame(phase = rep(rep(c("light", "dark", "light"),c(5,6,1)),2),
conds = rep(c("beau", "ophio_cflo"), each=12))
row.names(my_sample_col) <- colnames(zscore.rhy.homology.dat)
# Manual color palette
my_colour = list(
phase = c(light = "#F2E18D", dark = "#010440"),
conds = c(beau = "#5A829F", ophio_cflo = "#AD212F"),
cluster = viridis::cividis(100)[c(seq(10,80,by=round(80/(n_clusters), 0)))])
# Color scale
my.breaks = seq(min(zscore.rhy.homology.dat), max(zscore.rhy.homology.dat), by=0.1)
# my.breaks = seq(min(zscore.rhy), max(zscore.rhy), by=0.06)
# Let's plot!
pheatmap(zscore.rhy.homology.dat, show_rownames = F, show_colnames = F,
annotation_row = my_gene_col,
annotation_col = my_sample_col,
cutree_rows = n_clusters, # OG was 4
# cutree_cols = 4,
gaps_col = c(12,24),
annotation_colors = my_colour,
border_color=FALSE,
cluster_cols = F,
breaks = my.breaks,
## color scheme borrowed from:
color = inferno(length(my.breaks) - 1),
treeheight_row = 0,
# treeheight_col = 0,
# remove the color scale or not
main = paste0("24h-rhythmic in Ocflo or Beau \n (n=",
nrow(zscore.rhy.homology.dat), " orthologous genes)"),
## annotation legend
annotation_legend = T,
## Color scale
legend = T)
# Chunk 15: ortho_rhy_zplots
sampleName <- c("ophio_cflo","ophio_ophio-infected")
for (j in 1:2) {
for (i in 1:n_clusters){
writeLines(paste0("Species: ", sample.name[[j]], "\n", "24h-rhythmic genes, Cluster: ", i))
# Summary
genes <- my_gene_col %>% rownames_to_column("g") %>% filter(cluster==as.character(i)) %>% pull(g)
writeLines(paste0("n(genes) = ", length(genes),"\n"))
# define the background geneset for enrichment analysis
bg.genes <- homology.dat %>% pull(ophio_gene) %>% unique()
## Transform gene names (ophio -> beau) and refine background geneset
if (j == 1) {
genes <-
homology.dat %>%
filter(ophio_gene %in% genes) %>%
pull(beau_gene)
bg.genes <- homology.dat %>% pull(beau_gene) %>% unique()
}
# Enrichment
overrepresented.terms <-
genes %>%
check_enrichment(.,
function.dir = path_to_repo,
what = "pfams",
org = sample.name[[j]],
bg = expressed[[j]],
filter = T,
plot = F)
print(overrepresented.terms)
writeLines(paste0("\n", "n(overrepresented terms) = ", nrow(overrepresented.terms), "\n"))
# Stacked zplot
if (j==2) {
# Stacked zplot
stacked.plot1 <- genes %>% stacked.zplot_tc6(cond = sampleName[[1]]) %>% pluck(1)
stacked.plot2 <- genes %>% stacked.zplot_tc6(cond = sampleName[[2]]) %>% pluck(1)
ggpubr::ggarrange(plotlist=list(stacked.plot1, stacked.plot2),
nrow = 1, ncol = 2,
widths = c(1,1), labels = NA) %>%
print()
} else {
genes %>%
stacked.zplot_tc6(cond = sample.name[[j]]) %>%
multi.plot(rows = 1, cols = 1)
}
}
}
# Chunk 16: ortho_rhy_cluster_overlap_v1
## Visualize the overlap
cluster.dat <- list()
for (i in 1:n_clusters) {
cluster.dat[[i]] <- my_gene_col %>%
rownames_to_column("g") %>% filter(cluster==as.character(i)) %>% pull(g)
}
names(cluster.dat) <- paste0("Cluster_",1:4)
for (j in 1:2) {
rhy.dat <- rhy[[j]]
cluster.dat.dummy <- cluster.dat
if (j == 1) {
for (i in 1:n_clusters) {
cluster.dat.dummy[[i]] <-
homology.dat %>%
filter(ophio_gene %in% cluster.dat.dummy[[i]]) %>%
pull(beau_gene)
}
}
listInput <- list(rhy.dat,
cluster.dat.dummy[[1]], cluster.dat.dummy[[2]],
cluster.dat.dummy[[3]], cluster.dat.dummy[[4]])
names(listInput) <- c(paste0(sample.name[[j]], c("_rhy24")), paste0("cluster_",1:4))
library(UpSetR)
library(viridis)
# caste.col <- c("#F23030","#1A80D9")
upset(fromList(listInput),
number.angles = 0, point.size = 3, line.size = 1.5,
mainbar.y.label = "Number of overlapping genes",
sets.x.label = "Sig. rhy genes",
text.scale = c(1.5, # y-axis label ("# overlapping genes")
2, # y-axis tick labels ("1000, 2000,..")
1.5, # label for histogram ("sig. rhy genes")
1, # tick labels for histogram
1.5, # set names ("Cflo-brain_08h,..")
1.5),
sets = names(listInput),
nintersects = 15,
keep.order = T,
sets.bar.color = viridis(1),
# adding queries
query.legend = "bottom"
) %>%
print()
}
# Chunk 17: ortho_rhy_cluster_overlap_v2
# LIST ONE - Cluster identity
list1 <- cluster.dat
names(list1) <- names(cluster.dat)
## LIST TWO - ophio rhythmic genes
beau.ortho.rhy <- homology.dat %>% filter(beau_gene %in% rhy[[1]]) %>% pull(ophio_gene) %>% unique()
ocflo.ortho.rhy <- homology.dat %>% filter(ophio_gene %in% rhy[[2]]) %>% pull(ophio_gene) %>% unique()
list2 <- list(beau.ortho.rhy, ocflo.ortho.rhy)
names(list2) <- paste0(sample.name[1:2], c("_24h"))
## CHECK FOR OVERLAP
library(GeneOverlap)
# define the background geneset
# in our case, it would be the number of orthologous genes between beau and Ophio_cflo
nGenes = homology.dat %>% pull(ophio_gene) %>% unique() %>% length()
## make a GOM object
gom.1v2 <- newGOM(list1, list2, genome.size = nGenes)
png(paste0(path_to_repo, "/results/figures/BD/ocflo_beau_orthologs_rhy_overlap.png"),
width = 15, height = 15, units = "cm", res = 300)
drawHeatmap(gom.1v2,
adj.p=T,
cutoff=0.01,
what="odds.ratio",
# what="Jaccard",
log.scale = T,
note.col = "grey60")
trash <- dev.off()
# Chunk 18: plot_ortho_rhy_cluster_overlap
knitr::include_graphics(paste0(path_to_repo, "/results/figures/BD/ocflo_beau_orthologs_rhy_overlap.png"))
# Chunk 19: gene_annotations
## Get the annotation data
ocflo.annots <- read.csv(paste0(path_to_repo, "/data/ophio_cflo_TC6_data.csv"), stringsAsFactors = F) %>% as.tibble()
ocflo.annots %<>%
filter(expressed=="yes") %>%
select(gene_name = gene_ID_ncbi, gene_ID_robin, blast_annot, GammaP_24h, GOs:ophio_kim_homolog)
## Subset the gene_names
ocflo.annots %>%
filter(gene_name %in% cluster.dat[[4]]) %>%
# plot the q-values
ggplot() +
geom_density(aes(x=GammaP_24h)) +
labs(x=paste0(sample.name[[2]]," rhythmicity, 24h (q-value)")) +
scale_x_continuous(breaks = c(0,0.05, 0.1, 0.5, 1)) +
theme_Publication()
# which genes?
# filter(!is.na(GOs)) %>%
# view()
## Check these genes for other annotations (signalP, SSP, TMHMM)
# LIST ONE - Cluster identity
list1 <- cluster.dat
names(list1) <- names(cluster.dat)
## LIST TWO - ophio rhythmic genes
signalP <- ocflo.annots %>% filter(signalP == "yes") %>% pull(gene_name)
SSP <- ocflo.annots %>% filter(SSP == "yes") %>% pull(gene_name)
TMHMM <- ocflo.annots %>% filter(TMHMM == "yes") %>% pull(gene_name)
list2 <- list(signalP, SSP, TMHMM)
names(list2) <- paste0(sample.name[[2]], "-", c("signalP", "SSP", "TMHMM"))
## CHECK FOR OVERLAP
library(GeneOverlap)
# define the background geneset
# in our case, it would be the number of orthologous genes between beau and Ophio_cflo
nGenes = ocflo.annots %>% nrow()
## make a GOM object
gom <- newGOM(list1, list2, genome.size = nGenes)
png(paste0(path_to_repo, "/results/figures/BD/ocflo_beau_orthologs_annots_overlap.png"),
width = 15, height = 15, units = "cm", res = 300)
drawHeatmap(gom,
adj.p=T,
cutoff=0.01,
what="odds.ratio",
# what="Jaccard",
log.scale = T,
note.col = "grey60")
trash <- dev.off()
# Chunk 20: plot_ortho_rhy_cluster_overlap_v2
knitr::include_graphics(paste0(path_to_repo, "/results/figures/BD/ocflo_beau_orthologs_annots_overlap.png"))
# Chunk 21: prep_v1
# Let's load functions for running limorhyde
source(system.file('extdata', 'vignette_functions.R', package = 'limorhyde'))
# Let's load the libraries required for running Limorhyde
# library('annotate')
library('data.table')
library('foreach')
# library('GEOquery')
library('ggplot2')
library('knitr')
library('limma')
library('limorhyde')
conflict_prefer("union", "dplyr")
# Chunk 22: create_metadata
sampleName <- c("ophio_cflo","ophio_ophio-infected")
short.name <- c("AC","AI") # AC = arb2-control, AI = arb2-infection
time.points <- c(2,4,6,8,10,12,14,16,18,20,22,24)
light.dark <- c(rep("light",times=5), rep("dark",times=6), rep("light", times=1))
meta <- data.frame(title = paste0(rep(sampleName, each=12),"_ZT",time.points),
sample = paste0(rep(time.points, times=2),rep(short.name, each=12)),
genotype = rep(sampleName, each=12),
time = rep(time.points, times=2),
cond = rep(sampleName, each=12),
LD = rep(light.dark, times=2),
stringsAsFactors = F)
meta %>% glimpse()
# Chunk 23: prep_v2
### 1.1.1 Format the meta-data ----------------
# load the meta-data
sm <- meta
# Let's format the columns in the right data-type
sm$time <- as.numeric(sm$time)
# sm$batch <- as.factor(sm$batch)
sm$LD <- as.factor(sm$LD)
# sm$location <- as.factor(sm$location)
# Let's get a glimpse of the metadata
sm %>% as_tibble() %>% head()
# Next we use limorhyde to calculate time_cos and time_sin, which are based on the first
#harmonic of a Fourier decomposition of the time column, and append them to the sm data frame.
sm = cbind(sm, limorhyde(sm$time, 'time_'))
# convert the dataframe into a data.table
sm <- data.table(sm)
# check that it worked
sm[1:5, ]
# Chunk 24: load_ophio_DEG_data
## DATASET 1
## Load the control O.cflo data (from TC6)
ocflo.control.dat <-
data.db %>%
tbl(., paste0(sampleName[[1]], "_fpkm")) %>%
select(gene_name, everything()) %>%
collect()
## DATASET 2
## Load the O.cflo infection data from the mixed transcriptomics study (from TC7)
inf.db <- dbConnect(RSQLite::SQLite(),
paste0(path_to_repo,"/../Das_et_al_2022b/data/databases/TC7_data.db"))
# src_dbi(inf.db)
# extract the (gene-expr X time-point) data
ocflo.inf.dat <-
inf.db %>%
tbl(., paste0(sampleName[[2]], "_fpkm")) %>%
select(gene_name, everything()) %>%
collect()
# Chunk 25: prep_v3
## DATASET 1
n.exp.1 <- apply(ocflo.control.dat[-1], 1, function(x) sum(x>=1))
ocflo.control.dat <- ocflo.control.dat[which(n.exp.1>=6),]
colnames(ocflo.control.dat)[-1] <- paste0("ZT", meta[meta$cond==sampleName[[1]],] %>% pull(sample))
## DATASET 2
n.exp.2 <- apply(ocflo.inf.dat[-1], 1, function(x) sum(x>=1))
ocflo.inf.dat <- ocflo.inf.dat[which(n.exp.2>=6),]
colnames(ocflo.inf.dat)[-1] <- paste0("ZT", meta[meta$cond==sampleName[[2]],] %>% pull(sample))
## Use the genes that are expressed in both conditions
emat <-
ocflo.control.dat %>%
filter(gene_name %in% ocflo.inf.dat$gene_name) %>%
left_join(ocflo.inf.dat, by="gene_name") %>%
as.data.frame()
# Chunk 26: run_DEG_anlayses
### Convert to a matrix
# save gene names as row names
rownames(emat) <- emat[,1]
emat <- emat[,-1]
# Need to make the emat into a matrix.
emat <- data.matrix(emat)
# log2 transform the data
emat <- log2(emat + 1)
### Set thresholds
# Set threshold for q-value and log2FC
q.threshold <- 0.05 # currently, using 5% FDR (BH adjusted p-value)
log2.foldchange <- 1 # thus, any gene with a 2^(log2.foldchange) fold change in it's expression
### Format the metadata, if necessary
# Filter the metadata according to your comparison
sm.sub <- sm %>% filter(cond %in% c(sampleName))
# Define the cond column as a factor
sm.sub$cond <- as.factor(sm.sub$cond)
### Let's run the DEG analyses
# Use the subsetted emat to find DEGs
design.deg = model.matrix(~ cond + time_cos + time_sin, data = sm.sub)
#
fit = lmFit(emat, design.deg)
fit = eBayes(fit, trend = TRUE)
# Take a look at the coefficients table
# fit$coefficients %>% head()
#
deLimma.deg = data.table(topTable(fit, coef = 2, number = Inf), keep.rownames = TRUE)
setnames(deLimma.deg, 'rn', 'gene_name')
deLimma.deg[, adj.P.Val := p.adjust(P.Value, method = 'BH')]
setorderv(deLimma.deg, 'adj.P.Val')
### Annotate the results
# Annotate the results to indicate the significant genes
all.DEGs <-
deLimma.deg %>%
arrange(desc(abs(logFC)), adj.P.Val) %>%
mutate(sig = as.factor(ifelse(adj.P.Val < q.threshold & abs(logFC) >= log2.foldchange, "yes", "no"))) %>%
mutate(inf_v_control = as.factor(ifelse(sig=="yes", ifelse( logFC > 0, "up", "down" ), "NA"))) %>%
mutate(inf = sampleName[[2]])
### Summarize the results
writeLines(paste0("\nControl-", sampleName[[1]], " v. ", sampleName[[2]], "\n--Results of DEG analysis--"))
## How many DEGs - 5% FDR and ≥ 1 fold change in gene expression
all.DEGs %>%
# filter(adj.P.Val < q.threshold) %>%
# filter(abs(logFC) >= 2) %>% # change the criteria here for top DEG or all DEG (logFC≥1)
filter(sig == "yes") %>%
# pull(gene_name) %>%
group_by(inf_v_control) %>%
summarise(n_genes = n()) %>%
as.data.frame() %>%
## n = 81 up- and 141 down-regulated genes in Cflo heads during Ophio-infection
## (at 5% FDR; log2-fold-change ≥ 1)
print()
### Subset to keep only sig. DEGs
sig.DEGs <- all.DEGs %>% filter(sig=="yes")
# Chunk 27: visualize_DEG_res
# Volcano plot
library(viridis)
ggplot(all.DEGs) +
# geom_hline(yintercept = -log10(0.05), col="red", alpha=0.6) +
# geom_vline(xintercept = c(-2,2), col="grey60", alpha=0.75) +
geom_point(aes(x = logFC, y = -log10(adj.P.Val), color=sig), size = 1.5, alpha = 0.5) +
labs(x = expression(log[2]*' fold-change (inf_v_control)'),
y = expression(-log[10]*' '*q[DE]),
title = "O.cflo (infection v. control)",
color = "significant") +
# scale_x_continuous(limits = c(-5,3),
#                    breaks = c(-5,-4,-3,-2,-1,0,1,2,3),
#                    labels = c("-5","","-3","","-1","","1","","3")) +
# xlim(c(-50,50)) +
theme_Publication() +
scale_color_viridis(discrete = T, direction = -1, option = "viridis")
# Chunk 28: will2020_data
## Load the ophio DEG (at manipulation) data from Will et al. 2020
will2020_data <- read.csv(paste0(path_to_repo,
"/data/input/ophio_cflo/complete_annotations/FullBlast_EC05_RNAseq_orignal_copy_26Aug19.csv"),
stringsAsFactors = F)
will2020_data %<>%
as_tibble() %>%
filter(sample_1=="Alive" & sample_2=="Fungus") %>%
select(arb2_gene, logFC = log2.fold_change., q_value, significant) %>%
mutate(logFC=as.numeric(logFC), q_value=as.numeric(q_value)) %>%
filter(significant=="yes") %>%
mutate(up_down = ifelse(logFC > 0, "down", "up")) %>%
mutate(logFC = -1*logFC) %>%
na.omit()
### Change ophio gene names to ncbi IDs
will2020_data %<>%
left_join(ocflo.annots[1:3], by=c("arb2_gene"="gene_ID_robin")) %>%
select(-1) %>%
select(gene_name, blast_annot, everything())
sample.name
# number of all genes
all.genes <- list()
for (i in 1:length(sample.name)) {
all.genes[[i]] <- tbl(data.db, paste0(sample.name[[i]] ,"_fpkm")) %>%
collect()
writeLines(paste("Number of genes in", sample.name[[i]], ":", nrow(all.genes[[i]])))
}
# A1: genes that have NO expression (FPKM == 0 at all time points)
not.expressed <- list()
for (i in 1:length(sample.name)) {
not.expressed[[i]] <-
tbl(data.db, paste0(sample.name[[i]] ,"_fpkm")) %>%
collect() %>%
filter_at(vars(starts_with("Z")), all_vars(. == 0)) %>%
pull(gene_name)
# How many genes are not expressed?
writeLines(paste("n(genes-NOT-EXPRESSED) in", sample.name[[i]], ":", length(not.expressed[[i]])))
}
# A2: run enrichment (make plot of enrichment found of non-expressed genes)
for (i in 1:length(sample.name)) {
writeLines(paste("running GO enrichment for NOT-EXPRESSED genes in", sample.name[[i]]))
# run enrichment
not.expressed[[i]] %>%
check_enrichment(.,
org = sample.name[[i]],
what = "pfams",
function.dir = path_to_repo,
bg = 'all') %>%
# # pull gene names for a given GO term
# separate_rows(., gene_name, sep = ", ") %>%
# filter(GO == "GO:0009405") %>% # pathogenesis
# # filter(GO == "GO:0090729") %>% # toxin activity
# # filter(GO == "GO:0044419") %>% # interspecies interaction between organisms
# # filter(GO == "GO:0020037") %>% # heme binding
# pull()
# go_enrichment_plot(clean = "no",
#                    function.dir = path_to_repo) %>%
print()
}
for (i in 1:2){
# exp.dat <- expressed[[i]]
rhy.dat <- rhy[[i]]
ortho.dat <- homology.dat %>% pull(i)
listInput <- list(rhy.dat, ortho.dat)
names(listInput) <- c(paste0(sample.name[[i]], c("_rhy24","_ortho")))
library(UpSetR)
library(viridis)
# caste.col <- c("#F23030","#1A80D9")
upset(fromList(listInput),
number.angles = 0, point.size = 3, line.size = 1.5,
mainbar.y.label = "Number of overlapping genes",
sets.x.label = "Sig. rhy genes",
text.scale = c(1.5, # y-axis label ("# overlapping genes")
2, # y-axis tick labels ("1000, 2000,..")
1.5, # label for histogram ("sig. rhy genes")
1, # tick labels for histogram
1.5, # set names ("Cflo-brain_08h,..")
1.5),
sets = names(listInput),
nintersects = 15,
keep.order = T,
sets.bar.color = viridis(1),
# adding queries
query.legend = "bottom"
) %>%
print()
writeLines(paste0(
"The above plot shows that of the ", length(rhy.dat), " rhythmic genes in ", sample.name[[i]],
", how many has an 1:1 ortholog in the other fungal species. \n",
"Note, orthologous genes were identified using proteinortho "))
}
rhy.dat[[1]] %>% head()
rhy.dat[[1]]
rhy.dat
rhy[[1]]
rhy[[1]] %>% head()
homology.dat %>% head()
homology.dat[[1]]
homology.dat[[2]]
rhy.not.homolog <- list()
sample.name
rhy.not.homolog <- list()
for(i in 1:2){
# save the names of genes
rhy.not.homolog[[i]] <- setdiff(rhy[[i]], homology.dat[[i]])
# run enrichment
rhy.not.homolog %>%
check_enrichment(.,
org=sample.name[[i]],
what = "pfams")
}
rhy.not.homolog <- list()
for(i in 1:2){
# save the names of genes
rhy.not.homolog[[i]] <- setdiff(rhy[[i]], homology.dat[[i]])
# run enrichment
rhy.not.homolog[[i]] %>%
check_enrichment(.,
org=sample.name[[i]],
what = "pfams")
}
remove.packages("timecourseRnaseq")
devtools::install_github("biplabendu/timecourseRnaseq")
library(timecourseRnaseq)
beau_annots
beau_annots %>% select(gene_desc)
beau_annots
timecourseRnaseq::beau_annots
beau_anntos
devtools::install_github("biplabendu/timecourseRnaseq")
beau_annots
timecourseRnaseq::cflo_annots
cflo_annots
