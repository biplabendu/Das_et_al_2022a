---
title: "Building and annotating GCN for O. camponoti-floridani (TC6)"
author: Biplabendu Das 
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: united
    keep_md: no
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = F)
knitr::opts_chunk$set(message = F)

## For more inspiration on customizing the html output, refer to the following:
# https://bookdown.org/yihui/rmarkdown/html-document.html#table-of-contents

```

```{r housekeeping, include=FALSE}
set.seed(420)
rm(list = ls())

#' Load the libraries
pacman::p_load(pheatmap, dendextend, tidyverse, viridis)
pacman::p_load(RSQLite, tidyverse, dbplyr, DT, conflicted, WGCNA, igraph)
pacman::p_load(patchwork)
library(timecourseRnaseq)

#' set conflict preference
conflict_prefer("select", "dplyr", quiet = T)
conflict_prefer("filter", "dplyr", quiet = T)
conflict_prefer("layout", "plotly", quiet = T)
conflict_prefer("hclust", "flashClust", quiet = T)

#' set path to your working directory
path_to_repo = "/Users/biplabendudas/Documents/GitHub/Das_et_al_2022a"

#' load functions
# customized theme for publication quality figures
source(paste0(path_to_repo,"/functions/theme_publication.R"))
# function to perform enrichment analysis
# source(paste0(path_to_repo,"/functions/enrichment_analysis.R"))
# function to plot z-scores (Cflo genes only)
source(paste0(path_to_repo,"/functions/plot_zscores.R"))

## List of metabolic processes (only top level metabolic process GO terms)
# source: http://www.informatics.jax.org/vocab/gene_ontology/GO:0008150

metabolism.gos <- c(metabolic_process = c("GO:0008152", "GO:0044236", "GO:0044710"),
                 adaptive_thermogenesis = c("GO:1990845"),
                 antibiotic_metabolic_process = "GO:0016999",
                 ATP_metabolic_process = "GO:0046034",
                 biosynthetic_process = c("GO:0009058", "GO:0044274", "GO:0044711"),
                 catabolic_process = c("GO:0009056", "GO:0044243", "GO:0044712"),
                 cellular_metabolic_process = "GO:0044237",
                 collagen_biosynthesis = "GO:0032964",
                 collagen_catabolic_process = "GO:0030574",
                 hormone_biosynthetic_process = "GO:0042446",
                 hormone_catabolic_process = "GO:0042447",
                 negative_regulation_of_hormone_metabolism = "GO:0032351",
                 positive_regulation_of_hormone_metabolism = "GO:0032352",
                 peptide_hormone_processing = "GO:0016486",
                 regulation_of_hormone_metabolism = "GO:0032350",
                 insulin_processing = "GO:0030070",
                 pheromone_metabolism = "GO:0042810",
                 carbohydrate_utilization = "GO:0009758")

locomotion.gos <- c(cell_motility = "GO:0048870",
                    directional_locomotion = "GO:0033058",
                    flight = "GO:0060361",
                    locomotory_behavior = c("GO:0031987", "GO:0007626"),
                    regulation_of_locomotion = "GO:0040012",
                    multicellular_organismal_locomotion = "GO:0071965",
                    negative_regulation_of_locomotion = "GO:0040013",
                    positive_regulation_of_locomotion = "GO:0040017",
                    taxis = "GO:0042330"
                    )

immune.gos <- c(immune_system_process = "GO:0002376",
                activation_of_immune_response = "GO:0002253",
                negative_regulation_of_immune_system = "GO:0002683",
                positive_regulation_of_immune_system = "GO:0002684",
                regulation_of_immune_system = "GO:0002682",
                immune_effector_process = "GO:0002252",   
                # Any process of the immune system that executes a component of an immune response. An effector immune process takes place after its activation.
                immune_response = "GO:0006955",
                immunological_memory_process = "GO:0090713",
                tolerance_induction = "GO:0002507",
                detoxification = "GO:0098754",
                toxin_catabolic_process = "GO:0009407",
                xenobiotic_detoxification = c("GO:0140330", "GO:1990961"),
                nitrogen_utilization = "GO:0019740")

interspecies.gos <- c(interspecies_interaction = c("GO:0044419", "GO:0051703"),
                      biological_regulation = "GO:0065007",
                      regulation_of_biological_quality = "GO:0065008",
                      signaling = c("GO:0023052", "GO:0023046", "GO:0044700"),
                      viral_process = c("GO:0016032", "GO:0022415"))

behavior.gos <- c(behavior = c("GO:0007610", "GO:0044708"),
                  rhythmic_behavior = "GO:0007622",
                  social_behavior = "GO:0035176",
                  thermosensory_behavior = "GO:0040040",
                  visual_behavior = "GO:0007632",
                  aggressive_behavior = "GO:0002118",
                  behavioral_defense_response = "GO:0002209",
                  behavioral_response_to_nutrient = "GO:0051780",
                  response_to_water_deprivation = "GO:0042630",
                  chemosensory_behavior = "GO:0007635",
                  olfactory_behavior = "GO:0042048",
                  exploration_behavior = "GO:0035640",
                  feeding_behavior = c("GO:0007631", "GO:0044366", "GO:0044367", "GO:0044368",
                                       "GO:0044369", "GO:0044370", "GO:0044371", "GO:0044372"),
                  foraging_behavior = c("GO:0060756"),
                  grooming_behavior = c("GO:0007625"),
                  host_seeking_behavior = "GO:0032537",
                  learning_memory = "GO:0007611",
                  mechanosensory_behavior = "GO:0007638",
                  response_to_stimulus = c("GO:0050896", "GO:0051869"),
                  motor_behavior = "GO:0061744",
                  negative_regulation_of_behavior = "GO:0048521",
                  positive_regulation_of_behavior = "GO:0048520",
                  regulation_of_behavior = "GO:0050795",
                  reproductive_behavior = "GO:0019098",
                  reproduction = c("GO:0000003", "GO:0019952", "GO:0050876"),
                  rhythmic_process = "GO:0048511")

gut.microbiota.gos <- c(sulfur_metabolism = "GO:0006790",
                        sulfur_amino_acid_metabolism = "GO:0000096",
                        regulation_of_sulfur_metabolism = "GO:0042762",
                        negative_regulation_of_sulfur_metabolism = "GO:0051175",
                        positive_regulation_of_sulfur_metabolism = "GO:0051176")


list.of.gos <- list("metabolism_gos" = metabolism.gos,
                    "locomotion_gos" = locomotion.gos,
                    "immune_gos" = immune.gos,
                    "interspecies_gos" = interspecies.gos,
                    "behavior_gos" = behavior.gos)


```


## Overview/Goals

Using time-course RNASeq data from Ophiocordyceps camponoti-floridani liquid culture: 

- build a circadian gene co-expression network (GCN), 
- annotate the network using published data,
- find rhytmic gene modules

## Step 1: Build circadian GCN

### 1.1 Load data

Dataset: O. camponoti-floridani grown in liquid culture as blastspore (three pooled per time point for RNA-extraction and -sequencing), collected every 2h, over a 24h-period. [Control]

```{r load_data}
# loading database which contains data for Das and de Bekker 2022, from GitHub
db <- dbConnect(RSQLite::SQLite(), paste0(path_to_repo,"/data/databases/TC6_fungal_data.db"))

# specify sample name
sample.name <- "ophio_cflo"

# extract the (gene-expr X time-point) data
dat <-
  db %>%
  tbl(., paste0(sample.name ,"_fpkm")) %>%
  select(gene_name, everything()) %>%
  collect()

writeLines("What is the dimensions of the original dataset? [Rows = #genes, Cols = #samples]")
dim(dat[-1])

```

### 1.2 Clean data

The above dataset contains all genes ??(n=13,808)?? (7455 genes, 12 samples) in the fungi genome. 
However, not all of these genes are expressed, and some are expressed at very low levels that are not biologically meaningful. Therefore, we will only keep the genes that are "expressed" (≥1 FPKM for at least half of all time points).

```{r clean_data}
# Which genes are expressed throughout the day in Ophio-cflo?
  # count the number of time points that has ≥ 1 FPKM
  n.expressed <- apply(dat[-1], 1, function(x) sum(x >= 1))
  # subset the data and only keep the filtered genes
  dat <- dat[which(n.expressed >=6),]

writeLines("Dimensions of the data post-filtering step [Rows = #genes, Cols = #samples]")
dim(dat)

```

This is our cleaned, input data file for building the circadian GCN. This contains 6874 genes in ??13?? samples.


### 1.3 Format data

- Log2 transform the data

```{r format_data}

datExpr = as.data.frame(t(log2(dat[-c(1)]+1)))
names(datExpr) = dat$gene_name
rownames(datExpr) = names(dat)[-c(1)]

# USE THE FOLLOWING CODE TO CHECK IF YOU HAVE ANY BAD SAMPLES #
  # gsg = goodSamplesGenes(datExpr, verbose = 3);
  # gsg$allOK

  # sampleTree = hclust(dist(datExpr0), method = "average");
  # # Plot the sample tree: Open a graphic output window of size 12 by 9 inches
  # # The user should change the dimensions if the window is too large or too small.
  # sizeGrWindow(12,9)
  # #pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
  # par(cex = 1);
  # par(mar = c(0,4,2,0))
  # plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
  #      cex.axis = 1.5, cex.main = 2)

# save the number of genes and samples
# that will be used to create the circadian GCN
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

# visualize the log-transformed data
x = reshape2::melt(as.matrix(t(datExpr)))
colnames(x) = c('gene_id', 'sample', 'value')

writeLines("Visualizing the log-transformed data")
ggplot(x, aes(x=value, color=sample)) + geom_density() + theme_Publication()

```

### 1.4 Calculate gene-gene similarity

```{r gene_sim_matrix}
# Calculate Kendall's tau-b correlation for each gene-gene pair

# sim_matrix <- cor((datExpr), method = "kendall") # this step takes time
# save(sim_matrix, file = paste0(path_to_repo, "/results/temp_files/sim_matrix_", sample.name, "_TC6.RData")) # might be useful to save the sim_matrix and
load(paste0(path_to_repo, "/results/temp_files/sim_matrix_", sample.name, "_TC6.RData")) # load it up

## Let's display a chunk of the matrix (code from Hughitt 2016; github)
heatmap_indices <- sample(nrow(sim_matrix), 200)

writeLines(paste0("Plotting a chunk of the gene-gene similarity matrix with ", length(heatmap_indices), " genes."))
gplots::heatmap.2(t(sim_matrix[heatmap_indices, heatmap_indices]),
          col=inferno(100),
          labRow=NA, labCol=NA,
          trace='none', dendrogram='row',
          xlab='Gene', ylab='Gene',
          main= paste0("Similarity matrix \n correlation method = 'kendall' \n (", length(heatmap_indices), "random genes)"),
          density.info='none', revC=TRUE)

```

### 1.5 Create adjacency matrix

- To create the adjacency matrix, we need to first identify the soft-thresholding power (see WGCNA for more info).

```{r soft_thresholding_power}
writeLines("Performing network topology analysis to pick soft-thresholding power")
# Choose a set of soft-thresholding powers
powers = c(c(1:10), seq(from = 12, to=30, by=2))
# # Call the network topology analysis function
sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)

writeLines("Plotting the resutls from the network topology analysis")
# Plot the results:
# sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# this line corresponds to using an R^2 cut-off of h
abline(h=0.90,col="red")
# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

```

NOTE: The scale-free topology fit index reaches ~0.846 at a soft-thresholding-power=8, and it gets saturated after that. R2 is used to quentify how well a scale-free netork satisfies, ranging from 0 (non-scale free topology) to 1 (scale free topology). Networks in a biological contest do resemble scale-free topology. When we maximize for scale-free model fit, there is a natural trade-off between mean number of connections. We want to pick a soft thresshold that satifies the scale-free network while maintaning the highest connectivity.

Now, we can go ahead and create our adjacency matrix by power-transforming the similarity matrix (see WGCNA for more info).

```{r adjacency_matrix}
## Specify the soft-thresholding-power which has been set at 8 for Ophio-cflo
soft.power = 8

# Construct adjacency matrix
# adj_matrix <- adjacency.fromSimilarity(sim_matrix,
#                                        power=soft.power,
#                                        type='signed')
# save(adj_matrix, file = paste0(path_to_repo, "/results/temp_files/adj_matrix_", sample.name, "_TC6.RData")) # might be useful to save the sim_matrix and
load(paste0(path_to_repo,"/results/temp_files/adj_matrix_", sample.name,"_TC6.RData")) # load it up


# Convert adj_matrix to matrix
gene_ids <- rownames(adj_matrix)

adj_matrix <- matrix(adj_matrix, nrow=nrow(adj_matrix))
rownames(adj_matrix) <- gene_ids
colnames(adj_matrix) <- gene_ids

writeLines(paste0("Plotting the power-transformed adjacency matrix for the same ", length(heatmap_indices)," genes as above"))
## Same heatmap as before, but now with the power-transformed adjacency matrix
gplots::heatmap.2(t(adj_matrix[heatmap_indices, heatmap_indices]),
                  col=inferno(100),
                  labRow=NA, labCol=NA,
                  trace='none', dendrogram='row',
                  xlab='Gene', ylab='Gene',
                  main='Adjacency matrix',
                  density.info='none', revC=TRUE)

## Delete similarity matrix to free up memory
rm(sim_matrix)
# gc()

```

***

## Step 2: Identify gene clusters

The following steps are performed as per guidelines from the WGCNA package and several tutorials made available online.

### 2.1 Create topological overalp matrix

```{r adj_to_TOM}
# Turn adjacency into topological overlap
# TOM = TOMsimilarity(adj_matrix);
# dissTOM = 1-TOM
# save(dissTOM, file = paste0(path_to_repo, "/results/temp_files/dissTOM_", sample.name, "_TC6.RData")) # might be useful to save the sim_matrix and
load(paste0(path_to_repo, "/results/temp_files/dissTOM_", sample.name, "_TC6.RData")) # load it up

# Call the hierarchical clustering function
geneTree = hclust(as.dist(dissTOM), method = "average")

writeLines("Plotting the resulting clustering tree (dendrogram)")
# sizeGrWindow(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)

```

### 2.2 Identify clusters

User defined parameters:

- minimum size (number of genes) of modules | var-name: minModuleSize

```{r identify_clusters}
# We like large modules, so we set the minimum module size relatively high:
minModuleSize = 50;

# Module identification using dynamic tree cut:
dynamicMods= cutreeDynamic(dendro = geneTree,
                           distM = dissTOM,
                           method = "hybrid",
                           verbose = 4,
                           deepSplit = 3, # see WGCNA for more info on tuning parameters
                           pamRespectsDendro = FALSE,
                           minClusterSize = minModuleSize);

# view number of genes in each module
table(dynamicMods)

writeLines("How many genes are there in each of the initial modules (clusters) detected?
Note: The names of the modules (colors) have no meaning.")
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
table(dynamicColors)

```

### 2.3 Merge similar modules

User defined parameters:

- minimum correlation between two modules above which they are merged into one | var-name: MEDissThres


```{r refine_cluster}
# Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes

# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs, method = "kendall");

writeLines("Clustering the module eigengenes and identifying a cutoff to merge similar modules")
# Cluster module eigengenes
METree = hclust(as.dist(MEDiss), method = "average");
# Plot the result
# sizeGrWindow(7, 8)
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "MEDiss = 1-cor(MEs, method = 'kendall')")

# We choose a height cut of 0.3
MEDissThres = 0.3 # user-specified parameter value; see WGCNA manual for more info

# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")

writeLines(paste0("Merging modules that have a correlation ≥ ", 1-MEDissThres))
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)

# The merged module colors
mergedColors = merge$colors;
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs;

writeLines("Plotting the identified clusters (denoted with colors) before and after merging.")
# sizeGrWindow(12, 9)
plotDendroAndColors(geneTree,
                    cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

# Rename to moduleColors
moduleColors = mergedColors

# Construct numerical labels corresponding to the colors
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1

```

### 2.4 Calculate module-module similarity

```{r module_sim_matrix}
writeLines("Calculating module-module similarity based on module-eigengene-expression.")
# Calculate similarity of the eigen-genes
sim_matrix_ME <- cor(mergedMEs, method = "kendall")

# calculate adj_matrix
adj_matrix_ME <- adjacency.fromSimilarity(sim_matrix_ME,
                                          power=1, # DO NOT power transform
                                          type='signed'
)

# coerce into a matrix
gene_ids <- rownames(adj_matrix_ME)
adj_matrix_ME <- matrix(adj_matrix_ME, nrow=nrow(adj_matrix_ME))
rownames(adj_matrix_ME) <- gene_ids
colnames(adj_matrix_ME) <- gene_ids

writeLines("Plotting the adjacency matrix that shows module-module similarity in expression")
gplots::heatmap.2(t(adj_matrix_ME),
                  col=inferno(100),
                  # labRow=NA, labCol=NA,
                  trace='none', dendrogram='row',
                  xlab='', ylab='',
                  # main='Similarity matrix - MEs \n correlation method = "kendall")',
                  main='Adjacency matrix - MEs \n modified edge weights)',
                  density.info='none', revC=TRUE)


```

### 2.5 Visualize the network

```{r visualize_network}
pacman::p_load(igraph)

# get rid of low correlations (0.6 & 0.8 are arbitrary) [0.7 and 0.9]
adj_matrix_ME[adj_matrix_ME < 0.6] <- 0
adj_matrix_ME[adj_matrix_ME < 0.8 & adj_matrix_ME>0] <- 0.5
adj_matrix_ME[adj_matrix_ME >= 0.8] <- 1

# build_network
network <- graph.adjacency(adj_matrix_ME,
                           mode = "upper",
                           weighted = T,
                           diag = F)

# simplify network
network <- igraph::simplify(network)  # removes self-loops

# E(network)$width <- E(network)$weight + min(E(network)$weight) + 1 # offset=1

colors <- mergedMEs %>% names() %>% str_split("ME", 2) %>% sapply("[", 2)
V(network)$color <- colors

genes_ME <- factor(moduleColors, levels=colors) %>% summary()
V(network)$size <- log2(genes_ME)*2

V(network)$label.color <- "black"
V(network)$frame.color <- "black"

E(network)$width <- E(network)$weight^2*4
E(network)$edge.color <- "gray80"

# par(mar=c(0,0,0,0))
# # remove unconnected nodes
# network <- delete.vertices(network, degree(network)==0)
# plot(network,
#      layout=layout.fruchterman.reingold
#      # layout = layout.kamada.kawai
#      # layout = layout.kamada.kawai
#      )

writeLines("Visualizing a simplified representation of the circadian GCN, with and without labels")
par(mfrow = c(1,2))
## Circular layout
plot(network,
     # layout=layout.kamada.kawai
       # layout=layout.fruchterman.reingold
       # layout=layout.graphopt
       layout=layout_in_circle,
     vertex.label=NA
     # vertex.size=hub.score(network)$vector*30
     # vertex.shape="none"
)

plot(network,
     # layout=layout.kamada.kawai
       # layout=layout.fruchterman.reingold
       # layout=layout.graphopt
       layout=layout_in_circle,
     # vertex.label=NA
     # vertex.size=hub.score(network)$vector*30
     vertex.shape="none"
)

```

## Step 3: Annotate the network

### 3.1 Define your genes of interest

```{r define_genes_of_interest}

# load ejtk database
ejtk.db <- dbConnect(RSQLite::SQLite(), paste0(path_to_repo,"/data/databases/TC6_fungal_ejtk.db"))

# DEFINE GENES OF INTEREST

rhy.24 <-
  tbl(ejtk.db, paste0(sample.name,"_zscores_24h")) %>% 
    filter(GammaP < 0.05) %>% pull(ID)

rhy.12 <-
  tbl(ejtk.db, paste0(sample.name,"_zscores_12h")) %>% 
    filter(GammaP < 0.05) %>% pull(ID)

rhy.08 <- 
  tbl(ejtk.db, paste0(sample.name,"_zscores_08h")) %>% 
    filter(GammaP < 0.05) %>% pull(ID)


# DRGs

```

### 3.2 Where are my genes of interest located?

```{r find_genes_in_network_1}
pacman::p_load(GeneOverlap)
# https://www.bioconductor.org/packages/devel/bioc/vignettes/GeneOverlap/inst/doc/GeneOverlap.pdf

# Make a list that returns gene names for a given cluster
module_color = colors
module = names(mergedMEs)
module_colors <-
  data.frame(module_label=module) %>%
  mutate(module_color = str_replace(module_label, "ME", ""))

module_genes <- list()
module_color <- module_colors$module_color
# Get the genes from each of the modules
for (i in 1:length(module_color)) {

  module_genes[[i]] <- names(datExpr)[which(moduleColors==module_color[[i]])]
  names(module_genes)[[i]] <- module_color[[i]]
}
# check the result | works
# names(module_genes)
# module_genes['salmon']

writeLines("#####################################################
How many genes are in each of my geneset of interest?
#####################################################")

## MAKE YOUR LIST OF GENES OF INTEREST ##

# LIST ONE - WGCNA modules
list1 <- module_genes
writeLines("List of interesting genes #1
----------------------------
Genes in each of the identified gene-clusters or modules")
sapply(list1, length)

## LIST TWO - rhythmic genes
list2 <- list(rhy.24, rhy.12, rhy.08)
writeLines("List of interesting genes #2
----------------------------
Rhythmic genes in control Cflo heads")
names(list2) <- paste0(sample.name, c("-24h", "-12h", "-08h"))
sapply(list2, length)


## CHECK FOR OVERLAP

## make a GOM object
gom.1v2 <- newGOM(list1, list2,
       genome.size = nGenes)
png(paste0(path_to_repo, "/results/figures/", sample.name,"_gom_1v2.png"), 
    width = 20, height = 30, units = "cm", res = 300)
drawHeatmap(gom.1v2,
              adj.p=T,
              cutoff=0.05,
              what="odds.ratio",
              # what="Jaccard",
              log.scale = T,
              note.col = "grey80")
trash <- dev.off()

writeLines("Visualizing the significant overlaps between your lists of interesting genes and the identified modules")


```


```{r plot_gom_1v2, echo = FALSE, fig.align='center', fig.cap='Gene-clusters with rhythmic genes', out.width="65%"}
knitr::include_graphics(paste0(path_to_repo, "/results/figures/", sample.name,"_gom_1v2.png"))
```

The above plot identifies the gene-clusters that contain most of the genes that show daily rhythms in healthy Cflo heads (Cflo-healthy-controls).

HOW TO READ THE FIGURE?

- Briefly explain here
- Talk about Odds-Ratio
- Darker the green, more significant is the overlap (also indicated by the adj_pval)

Next, we can try to identify the ant gene-clusters that underlie behavioral plasticity, as well as the ant clusters that are affected during behavioral manipulation induced by *Ophiocordyceps*.


```{r export_module_info, eval=F}

for(i in 1:length(module_genes)){
  
  if(i == 1){
    
    foo <- data.frame(gene_name = module_genes[[i]],
                      module_identity = names(module_genes)[i])
    
  }
  
  else {
    
    bar <- data.frame(gene_name = module_genes[[i]],
                      module_identity = names(module_genes)[i])
    
    foo <- rbind(foo,bar)
    
  }
  
  
}

foo %>% 
  mutate(GCN = sample.name) %>% 
  write.csv(paste0(path_to_repo,"/results/networks/", sample.name,"_genes_and_module_identity.csv"),
            row.names = F)


```


########## Till Here....


